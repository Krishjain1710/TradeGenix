# -*- coding: utf-8 -*-
"""Mini_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1abB_WtWULGDEfI1002HZtkFDXLEiMCaZ
"""

import yfinance as yf
import pandas as pd
from tqdm import tqdm
import os
import time
from datetime import datetime

# 🔹 Define Nifty Stock Lists
NIFTY_50 = [
    "RELIANCE", "HDFCBANK", "ICICIBANK", "INFY", "HDFC", "TCS", "KOTAKBANK", "HINDUNILVR",
    "ITC", "BHARTIARTL", "SBIN", "BAJFINANCE", "ASIANPAINT", "AXISBANK", "MARUTI", "ULTRACEMCO",
    "TITAN", "SUNPHARMA", "NESTLEIND", "ONGC", "POWERGRID", "NTPC", "HCLTECH", "TECHM",
    "WIPRO", "COALINDIA", "JSWSTEEL", "TATAMOTORS", "SHREECEM", "TATASTEEL", "BPCL", "INDUSINDBK",
    "IOC", "GRASIM", "CIPLA", "EICHERMOT", "DRREDDY", "HEROMOTOCO", "BRITANNIA", "UPL",
    "TATACONSUM", "BAJAJFINSV", "ADANIPORTS", "HINDALCO", "M&M", "LT", "TITAN", "SUNPHARMA"
]

# Create directories for each index
INDICES = {
    'nifty50': NIFTY_50,
    # Add NIFTY_100 and NIFTY_500 lists here
}

def create_index_directories():
    """Create directories for each index if they don't exist."""
    for index_name in INDICES.keys():
        dir_path = f'data/{index_name}'
        if not os.path.exists(dir_path):
            os.makedirs(dir_path)
            print(f"Created directory: {dir_path}")

def fetch_historical_data(symbol, index_name, max_retries=5, initial_delay=5):
    """Fetch 10 years of stock data and save to CSV with improved retry logic."""
    print(f"📥 Fetching historical data for {symbol}...")

    # Define the CSV file path with index-specific directory
    csv_path = f'data/{index_name}/{symbol}.NS_historical_data.csv'

    # Check if file exists and get the latest date
    latest_date = None
    if os.path.exists(csv_path):
        existing_df = pd.read_csv(csv_path)
        if not existing_df.empty:
            latest_date = pd.to_datetime(existing_df['Date'].max())

    # Fetch data with retry logic
    for attempt in range(max_retries):
        try:
            # Add longer delay between attempts
            if attempt > 0:
                wait_time = initial_delay * (2 ** attempt)  # Exponential backoff
                print(f"⏳ Waiting {wait_time} seconds before retry {attempt + 1}/{max_retries}...")
                time.sleep(wait_time)

            # Fetch last 10 years of data
            ticker = yf.Ticker(f"{symbol}.NS")
            df = ticker.history(period="10y", interval="1d")
            df.reset_index(inplace=True)

            # Filter out data that's already in the CSV
            if latest_date:
                df = df[df['Date'] > latest_date]

            if not df.empty:
                # Save new data to CSV
                df.to_csv(csv_path, mode='a', header=not os.path.exists(csv_path), index=False)
                print(f"✅ New historical data for {symbol} stored successfully!")
            else:
                print(f"ℹ️ No new data to store for {symbol}")

            # Add delay between successful requests
            time.sleep(initial_delay)
            return True

        except Exception as e:
            if "YFRateLimitError" in str(e):
                print(f"⚠️ Rate limit hit for {symbol}. Will retry...")
            else:
                print(f"❌ Error fetching data for {symbol}: {str(e)}")
                return False

    print(f"❌ Failed to fetch data for {symbol} after {max_retries} attempts")
    return False

def main():
    # Create directories for each index
    create_index_directories()

    # Process each index
    for index_name, stocks in INDICES.items():
        print(f"\n📊 Processing {index_name.upper()} stocks...")
        successful_fetches = 0
        failed_fetches = []

        for stock in tqdm(stocks, desc=f"Fetching {index_name} data"):
            if fetch_historical_data(stock, index_name):
                successful_fetches += 1
            else:
                failed_fetches.append(stock)
            # Add a longer delay between stocks
            time.sleep(10)  # 10 second delay between stocks

        # Print summary for this index
        print(f"\n{index_name.upper()} Data Fetch Summary:")
        print(f"✅ Successfully fetched: {successful_fetches} stocks")
        if failed_fetches:
            print(f"❌ Failed to fetch: {len(failed_fetches)} stocks")
            print("Failed stocks:", ", ".join(failed_fetches))

if __name__ == "__main__":
    main()

!pip install yfinance

import pandas as pd

# Load the historical data for RELIANCE
reliance_df = pd.read_csv('data/nifty50/RELIANCE.NS_historical_data.csv')
print(reliance_df.head())

import pandas as pd
from sklearn.preprocessing import MinMaxScaler

def preprocess_data(df):
    """
    Preprocesses the stock data.

    Args:
        df (pd.DataFrame): The input DataFrame.

    Returns:
        pd.DataFrame: The preprocessed DataFrame.
    """

    # 1. Handle Missing Data (Forward Fill)
    df.fillna(method='ffill', inplace=True)
    df.dropna(inplace=True)  # Remove any remaining NaNs after forward fill

    # 2. Normalization (Min-Max Scaling) - Important for LSTM
    scaler = MinMaxScaler()
    df[['Open', 'High', 'Low', 'Close', 'Volume']] = scaler.fit_transform(df[['Open', 'High', 'Low', 'Close', 'Volume']])

    return df

# Load your data (replace with your actual file path)
df = pd.read_csv('data/nifty50/RELIANCE.NS_historical_data.csv')
df = preprocess_data(df)

print(df.head())

def create_features(df):
    """
    Creates technical indicators.

    Args:
        df (pd.DataFrame): The input DataFrame.

    Returns:
        pd.DataFrame: The DataFrame with added features.
    """

    df['MA_5'] = df['Close'].rolling(window=5).mean()
    df['MA_20'] = df['Close'].rolling(window=20).mean()

    # RSI (Relative Strength Index)
    delta = df['Close'].diff()
    up = delta.clip(lower=0)
    down = -1 * delta.clip(upper=0)
    ma_up = up.rolling(window=14).mean()
    ma_down = down.rolling(window=14).mean()
    df['RSI'] = 100 - (100 / (1 + (ma_up / ma_down)))

    df['Volatility'] = df['Close'].rolling(window=20).std()
    df['Returns'] = df['Close'].pct_change()

    df.dropna(inplace=True)  # Drop rows with NaN created by rolling functions
    return df

df = create_features(df)
print(df.head())

import numpy as np
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

def create_lstm_model(input_shape):
    """
    Creates and compiles an LSTM model.

    Args:
        input_shape (tuple): The shape of the input data (time steps, features).

    Returns:
        tf.keras.Model: The compiled LSTM model.
    """

    model = Sequential()
    model.add(LSTM(units=50, return_sequences=True, input_shape=input_shape))  # First LSTM layer
    model.add(LSTM(units=50))  # Second LSTM layer
    model.add(Dense(units=1))  # Output layer (predicting one value - e.g., Close price)
    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

def prepare_lstm_data(df, target_column='Close', time_steps=20):
    """
    Prepares data for LSTM input.

    Args:
        df (pd.DataFrame): The input DataFrame.
        target_column (str): The column to predict (e.g., 'Close').
        time_steps (int): The number of time steps to use for prediction.

    Returns:
        tuple: X (input sequences), y (target values), X_train, X_test, y_train, y_test.
    """

    features = df.drop(columns=[target_column, 'Date']).values  # Use all features except Date and target
    target = df[target_column].values
    data = np.concatenate((features, target.reshape(-1, 1)), axis=1)  # Combine features and target

    X, y = [], []
    for i in range(time_steps, len(data)):
        X.append(data[i - time_steps:i])
        y.append(target[i])
    X, y = np.array(X), np.array(y)

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)  # Split data
    return X, y, X_train, X_test, y_train, y_test

# Prepare LSTM data
X, y, X_train, X_test, y_train, y_test = prepare_lstm_data(df)  # Assuming 'df' is your preprocessed and feature-engineered DataFrame
input_shape = (X_train.shape[1], X_train.shape[2])  # (time_steps, features)

# Create and train the LSTM model
lstm_model = create_lstm_model(input_shape)
lstm_model.fit(X_train, y_train, epochs=50, batch_size=32, verbose=1)

# Evaluate the model
loss = lstm_model.evaluate(X_test, y_test, verbose=0)
print(f"LSTM Loss on Test Data: {loss}")

# Make Predictions
predictions = lstm_model.predict(X_test)

#Remember to inverse transform 'predictions' and 'y_test' to original scale for meaningful evaluation if you normalized the data.

import numpy as np
import pandas as pd
import random

class TradingEnvironment:
    """
    A simplified trading environment.
    """

    def __init__(self, df, initial_capital=10000):
        self.df = df.reset_index()
        self.initial_capital = initial_capital
        self.reset()

    def reset(self):
        self.current_step = 0
        self.balance = self.initial_capital
        self.shares_held = 0
        self.net_worths = [self.balance]
        self.done = False
        return self._next_observation()

    def _next_observation(self):
        obs = self.df.loc[self.current_step, ['Open', 'High', 'Low', 'Close', 'Volume', 'MA_5', 'MA_20', 'RSI', 'Volatility', 'Returns']].values
        return obs

    def _take_action(self, action):
        # 0: Hold, 1: Buy, 2: Sell
        current_price = self.df.loc[self.current_step, 'Close']
        prev_close = self.df.loc[self.current_step - 1, 'Close'] if self.current_step > 0 else current_price  # Avoid index out of bounds

        if action == 1:  # Buy
            # Add a check for current_price being zero
            if current_price > 1e-6:  # Use a small threshold to handle near-zero values
                affordable_shares = int(self.balance / current_price)
                if affordable_shares > 0:
                    self.shares_held += affordable_shares
                    self.balance -= current_price * affordable_shares
            else:
                # Handle the case where price is zero or near zero, perhaps by doing nothing
                print(f"⚠️ Cannot buy: Current price is zero or near zero at step {self.current_step}")

        elif action == 2:  # Sell
            self.balance += current_price * self.shares_held
            self.shares_held = 0

    def step(self, action):
        self._take_action(action)
        self.current_step += 1
        self.net_worth = self.balance + self.shares_held * self.df.loc[self.current_step, 'Close']
        self.net_worths.append(self.net_worth)

        if self.current_step >= len(self.df) - 1:
            self.done = True

        obs = self._next_observation()
        reward = self.net_worth - self.net_worths[-2]  # Change in net worth
        return obs, reward, self.done, {}  # Return obs as numpy array

def random_trading_agent(env, episodes=10):
    """
    A simple agent that takes random actions.  For demonstration only!
    """

    for episode in range(episodes):
        state = env.reset()
        done = False
        total_reward = 0
        while not done:
            action = random.choice([0, 1, 2])  # Random action
            next_state, reward, done, _ = env.step(action)
            total_reward += reward
        print(f"Episode {episode + 1}, Final Net Worth: {env.net_worth:.2f}")

# Initialize and run the environment with a random agent
env = TradingEnvironment(df)  # Assuming 'df' is your processed DataFrame
random_trading_agent(env, episodes=5)

def _take_action(self, action):
        # 0: Hold, 1: Buy, 2: Sell
        current_price = self.df.loc[self.current_step, 'Close']
        prev_close = self.df.loc[self.current_step - 1, 'Close'] if self.current_step > 0 else current_price  # Avoid index out of bounds

        if action == 1:  # Buy
            # Add a check for current_price being zero
            if current_price > 1e-6:  # Use a small threshold to handle near-zero values
                affordable_shares = int(self.balance / current_price)
                if affordable_shares > 0:
                    self.shares_held += affordable_shares
                    self.balance -= current_price * affordable_shares
            else:
                # Handle the case where price is zero or near zero, perhaps by doing nothing
                print(f"⚠️ Cannot buy: Current price is zero or near zero at step {self.current_step}")

        elif action == 2:  # Sell
            self.balance += current_price * self.shares_held
            self.shares_held = 0

import numpy as np
import pandas as pd
# Assuming 'df' is your processed DataFrame from previous steps

def implement_stop_loss(df, stop_loss_pct=0.02):
    """
    Implements a simple dynamic stop-loss.

    Args:
        df (pd.DataFrame): DataFrame with 'Signal' (1, -1, 0) and 'Close' prices.
        stop_loss_pct (float): Percentage below the buy price to set the stop-loss.

    Returns:
        pd.DataFrame: DataFrame with 'Stop_Loss_Price' and 'Trade_Outcome'.
    """

    df['Stop_Loss_Price'] = np.nan
    df['Trade_Outcome'] = 0  # 1: Win, -1: Loss, 0: Neutral
    position = 0  # 0: No position, 1: Long (bought)

    # Create a copy to avoid modifying the original df directly within the loop
    df_copy = df.copy()

    for i in range(1, len(df_copy)):
        # Ensure 'Signal' column exists and handle potential NaN values
        signal_val = df_copy['Signal'].iloc[i] if 'Signal' in df_copy.columns and not pd.isna(df_copy['Signal'].iloc[i]) else 0
        current_close = df_copy['Close'].iloc[i]

        if signal_val == 1 and position == 0:  # Buy signal and no current position
            position = 1
            buy_price = current_close
            # Ensure index exists before assignment
            if i < len(df_copy):
                 df_copy.loc[i, 'Stop_Loss_Price'] = buy_price * (1 - stop_loss_pct)

        elif position == 1:  # Holding a position
             # Get the stop loss price from the row where the position was initiated.
             # This requires storing the buy index or propagating the stop_loss_price.
             # For simplicity, let's assume stop_loss_price is carried forward or needs recalculation.
             # A better approach for a dynamic stop-loss would involve tracking the last buy price.
             # For this fix, let's assume the intention was to check against the stop loss set at the buy point.
             # Since we don't have the buy price readily available here without more state,
             # let's modify this logic. A common dynamic stop loss tracks the highest price since entry.

             # Alternative Dynamic Stop Loss (Trailing Stop)
             # If position == 1, update the stop loss based on the highest price reached.
             # This requires storing the entry price and highest price since entry.
             # This implementation was likely intended as a fixed stop-loss based on the entry price.
             # Let's stick to the original intent but fix the index access issue.

             # The original logic seems to assume Stop_Loss_Price is available at index i,
             # which is only set when a buy signal occurs at index i. This is incorrect.
             # The stop loss should be compared against the price at index i, using the stop loss price set
             # at the time of the buy signal (an earlier index).

             # To correctly implement the intended fixed stop loss:
             # We need to track the stop loss price from the row where the buy signal occurred.
             # Let's refactor this section.

             # Reset position and outcome based on sell signal or hitting stop loss
            stop_loss_price_at_buy = None
            # Find the stop loss price from the last buy signal
            for j in range(i - 1, -1, -1):
                if df_copy['Signal'].iloc[j] == 1:
                    stop_loss_price_at_buy = df_copy['Close'].iloc[j] * (1 - stop_loss_pct)
                    break

            if stop_loss_price_at_buy is not None and current_close <= stop_loss_price_at_buy:
                df_copy.loc[i, 'Trade_Outcome'] = -1  # Loss
                position = 0
            elif signal_val == -1:  # Sell signal
                df_copy.loc[i, 'Trade_Outcome'] = 1  # Win (or loss, but we'll simplify)
                position = 0
            # Note: The original code also had an issue where Stop_Loss_Price was only set on the buy day.
            # For a trailing stop or carrying forward a stop loss, this column would need to be populated differently.
            # Since the logic is simplified, the Trade_Outcome is the primary focus here.

    return df_copy

# Assume 'df' is the DataFrame after preprocessing and feature creation.
# Add a dummy 'Signal' column for demonstration purposes
# In a real scenario, this 'Signal' column would be generated by your trading strategy (e.g., LSTM model predictions).
# Example: Add a simple signal based on MA crossover (for demonstration)
df['Signal'] = 0 # Initialize signal column

# Simple MA crossover signal (example)
# This is a placeholder; replace with your actual strategy's signal generation
df.loc[df['MA_5'] > df['MA_20'], 'Signal'] = 1  # Buy signal when short MA crosses above long MA
df.loc[df['MA_5'] < df['MA_20'], 'Signal'] = -1 # Sell signal when short MA crosses below long MA

# Now, call the function with the 'df' DataFrame which now includes the 'Signal' column
# and assign the result to df_with_stop_loss.
df_with_stop_loss = implement_stop_loss(df.copy())

print(df_with_stop_loss[['Date', 'Close', 'Signal', 'Stop_Loss_Price', 'Trade_Outcome']].tail(20))

import numpy as np
import pandas as pd
# Assuming 'df' is your processed DataFrame from previous steps

def implement_stop_loss(df, stop_loss_pct=0.02):
    """
    Implements a simple dynamic stop-loss.

    Args:
        df (pd.DataFrame): DataFrame with 'Signal' (1, -1, 0) and 'Close' prices.
        stop_loss_pct (float): Percentage below the buy price to set the stop-loss.

    Returns:
        pd.DataFrame: DataFrame with 'Stop_Loss_Price' and 'Trade_Outcome'.
    """

    df['Stop_Loss_Price'] = np.nan
    df['Trade_Outcome'] = 0  # 1: Win, -1: Loss, 0: Neutral
    position = 0  # 0: No position, 1: Long (bought)
    buy_price = np.nan # Track the price at which the position was entered

    # Create a copy to avoid modifying the original df directly within the loop
    df_copy = df.copy()

    for i in range(1, len(df_copy)):
        # Ensure 'Signal' column exists and handle potential NaN values
        # Use .iloc for integer-location based indexing for safety in loop
        signal_val = df_copy['Signal'].iloc[i] if 'Signal' in df_copy.columns and not pd.isna(df_copy['Signal'].iloc[i]) else 0
        current_close = df_copy['Close'].iloc[i]

        if signal_val == 1 and position == 0:  # Buy signal and no current position
            position = 1
            buy_price = current_close
            # Set the initial stop loss price when entering a position
            df_copy.loc[i, 'Stop_Loss_Price'] = buy_price * (1 - stop_loss_pct)

        elif position == 1:  # Holding a position
            # Carry forward the stop loss price from the buy point for comparison
            # This assumes a fixed stop loss based on the entry price.
            # For a trailing stop, the logic here would be different (e.g., updating stop_loss based on max price).
            stop_loss_price_at_buy = buy_price * (1 - stop_loss_pct) if not pd.isna(buy_price) else np.nan

            # Check if stop loss is hit
            if not pd.isna(stop_loss_price_at_buy) and current_close <= stop_loss_price_at_buy:
                df_copy.loc[i, 'Trade_Outcome'] = -1  # Loss (Stop loss hit)
                position = 0
                buy_price = np.nan # Reset buy price
            elif signal_val == -1:  # Sell signal
                df_copy.loc[i, 'Trade_Outcome'] = 1  # Win (or loss, based on exit vs entry price, simplified here)
                position = 0
                buy_price = np.nan # Reset buy price
            # If holding (action 0 or no signal) and stop loss not hit, position remains 1.
            # The Stop_Loss_Price column might need to be populated differently if you want
            # to visualize it, but for the trade logic based on a fixed entry stop loss,
            # we only need the buy_price and stop_loss_pct. However, the original code
            # attempted to populate 'Stop_Loss_Price' column, so let's continue that,
            # propagating the stop loss price while in a position.
            elif position == 1:
                 # Propagate the stop loss price while holding the position
                 # Find the stop loss from the most recent buy signal
                 last_buy_index = df_copy.index[(df_copy['Signal'] == 1) & (df_copy.index < i)].max()
                 if not pd.isna(last_buy_index):
                      buy_price_at_last_buy = df_copy.loc[last_buy_index, 'Close']
                      df_copy.loc[i, 'Stop_Loss_Price'] = buy_price_at_last_buy * (1 - stop_loss_pct)


    return df_copy

# Assume 'df' is the DataFrame after preprocessing and feature creation.
# Add a 'Signal' column. This column must exist for the implement_stop_loss function.
# If your actual strategy (e.g., based on LSTM predictions) generates a 'Signal' column
# elsewhere, ensure that DataFrame is named 'df' or adjust the code below.
# Example: Add a simple signal based on MA crossover (for demonstration)
df['Signal'] = 0 # Initialize signal column

# Simple MA crossover signal (example - replace with your strategy's signal)
# Ensure the necessary columns ('MA_5', 'MA_20') exist in 'df' before this step.
# Handle potential NaNs that might exist after feature creation but before dropping them.
df_copy_for_signals = df.copy() # Work on a copy for signal generation to avoid modifying df mid-process
df_copy_for_signals.dropna(subset=['MA_5', 'MA_20'], inplace=True) # Ensure NaNs from rolling window are handled

if 'MA_5' in df_copy_for_signals.columns and 'MA_20' in df_copy_for_signals.columns:
    df_copy_for_signals.loc[df_copy_for_signals['MA_5'] > df_copy_for_signals['MA_20'], 'Signal'] = 1  # Buy signal
    df_copy_for_signals.loc[df_copy_for_signals['MA_5'] < df_copy_for_signals['MA_20'], 'Signal'] = -1 # Sell signal
else:
    print("Warning: MA_5 or MA_20 columns not found in DataFrame. Cannot generate example signals.")


# Now, call the function with the DataFrame which now includes the 'Signal' column
# Pass the DataFrame with signals (df_copy_for_signals) to the function.
df_with_stop_loss = implement_stop_loss(df_copy_for_signals.copy()) # Use .copy() to avoid modifying the input df

# Make sure the 'Date' column is not dropped if you need it for the print statement
# Also, handle potential index alignment issues if NaNs were dropped after feature creation.
# It's best to apply the stop loss logic *after* all necessary features and the signal are in place
# and any rows with leading NaNs from rolling windows have been dropped.

# Print the tail, ensuring columns exist
cols_to_print = ['Date', 'Close', 'Signal', 'Stop_Loss_Price', 'Trade_Outcome']
existing_cols = [col for col in cols_to_print if col in df_with_stop_loss.columns]

print(df_with_stop_loss[existing_cols].tail(20))

import pandas as pd
from textblob import TextBlob
import numpy as np # Import numpy as it was used implicitly before

def analyze_sentiment(text):
    """
    Analyzes the sentiment of a text and returns a polarity score.
    Polarity is between -1 (negative) and 1 (positive).
    """
    analysis = TextBlob(text)
    return analysis.sentiment.polarity

# Sample news data (replace with your actual data)
news_data = [
    {"Date": "2024-01-01", "Headline": "Stock market surges to new record high!", "Text": "Investors are optimistic about the economy."},
    {"Date": "2024-01-01", "Headline": "Company X reports disappointing earnings.", "Text": "Shares of Company X plummet."},
    {"Date": "2024-01-02", "Headline": "Interest rates remain unchanged.", "Text": "Market sentiment is neutral."},
    {"Date": "2024-01-02", "Headline": "Breakthrough in AI research!", "Text": "Tech stocks rally."},
]
news_df = pd.DataFrame(news_data)

# Apply sentiment analysis
news_df['Sentiment_Score'] = news_df['Text'].apply(analyze_sentiment)

# Aggregate daily sentiment (simple average)
daily_sentiment = news_df.groupby('Date')['Sentiment_Score'].mean().reset_index()

print(daily_sentiment)

# Merge sentiment with your stock data (assuming 'df' is your stock DataFrame)

# Ensure 'Date' column in df is converted to datetime and remove timezone info if present
df['Date'] = pd.to_datetime(df['Date'])
# Corrected check: check .dt.tz instead of .dtype.tz
if df['Date'].dt.tz is not None:
    df['Date'] = df['Date'].dt.tz_convert(None) # Convert timezone to UTC then remove timezone info


# Ensure 'Date' column in daily_sentiment is converted to datetime and remove timezone info if present
daily_sentiment['Date'] = pd.to_datetime(daily_sentiment['Date'])
# Corrected check: check .dt.tz instead of .dtype.tz
if daily_sentiment['Date'].dt.tz is not None:
     daily_sentiment['Date'] = daily_sentiment['Date'].dt.tz_convert(None) # Convert and remove timezone


# Now merge the dataframes
df_with_sentiment = pd.merge(df, daily_sentiment, on='Date', how='left')
df_with_sentiment['Sentiment_Score'].fillna(0, inplace=True)  # Handle missing sentiment scores

print(df_with_sentiment.head())

import numpy as np
import pandas as pd
# Assuming 'df_with_stop_loss' is your processed DataFrame from previous steps

def backtest_strategy(df, initial_capital=10000):
    """
    Backtests a trading strategy.

    Args:
        df (pd.DataFrame): DataFrame with 'Signal' and 'Close' prices (and potentially 'Sentiment_Score').
        initial_capital (float): The starting capital.

    Returns:
        dict: A dictionary of performance metrics.
    """

    # --- Ensure 'Date' column is datetime within the function scope ---
    # This adds a layer of safety if the date conversion failed or was inconsistent before.
    # Use errors='coerce' to turn unparseable dates into NaT (Not a Time).
    if 'Date' in df.columns:
        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
        # Drop rows where date conversion failed, as they cannot be used for time calculations
        df.dropna(subset=['Date'], inplace=True)
        # Remove timezone information if present
        if df['Date'].dt.tz is not None:
            df['Date'] = df['Date'].dt.tz_convert(None)


    balance = initial_capital
    shares = 0
    in_position = False
    buy_price = 0
    trade_logs = []  # To store individual trade details

    # Use .iloc for integer-location based indexing and start loop from 1
    # Iterate through each day from the second day onwards to allow for comparison with the previous day if needed,
    # and to ensure rolling window indicators are populated.

    for i in range(1, len(df)):
        # Access current day's data using integer location i
        # Use .iloc to avoid potential issues with non-integer indices
        current_signal = df['Signal'].iloc[i] if 'Signal' in df.columns else 0 # Default to 0 if Signal column doesn't exist (shouldn't happen here but good practice)
        current_close = df['Close'].iloc[i]
        # Handle potential NaN stop loss values
        current_stop_loss = df['Stop_Loss_Price'].iloc[i] if 'Stop_Loss_Price' in df.columns else np.nan

        # --- Trading Logic ---
        if current_signal == 1 and not in_position:  # Buy signal and not in position
            # Ensure close price is positive before buying
            if current_close > 0:
                 shares_to_buy = balance // current_close # Integer division to get whole shares
                 if shares_to_buy > 0: # Ensure we can buy at least one share
                      shares = shares_to_buy
                      balance -= shares * current_close
                      buy_price = current_close
                      in_position = True
                 # else: Not enough capital to buy at least one share

        # Check for Sell or Stop-Loss trigger *on the current day*
        # If in position AND (sell signal received OR stop loss is hit)
        elif in_position: # Only check sell conditions if currently in a position
             sell_triggered = (current_signal == -1)
             stop_loss_triggered = (not pd.isna(current_stop_loss) and current_close <= current_stop_loss)

             if sell_triggered or stop_loss_triggered:
                sell_price = current_close
                # Ensure there was an active trade (shares > 0 from a previous buy)
                if shares > 0:
                    profit = (sell_price - buy_price) * shares # Calculate profit for the trade being closed
                    balance += shares * sell_price # Sell all shares
                    trade_logs.append({"Buy_Price": buy_price, "Sell_Price": sell_price, "Shares_Sold": shares, "Profit": profit, "Exit_Date_Index": i})

                shares = 0 # Shares are sold
                in_position = False
                buy_price = 0 # Reset buy price


    # Calculate final value after loop
    final_value = balance
    if in_position: # If still holding shares at the end
        final_value += shares * df['Close'].iloc[-1] # Value of remaining shares at the last close price


    # --- Performance Metrics Calculation ---

    total_return = (final_value - initial_capital) / initial_capital

    # Annualized Return calculation needs the number of *years* in the data, not just length of df.
    # Assuming df['Date'] exists and is datetime:
    annualized_return = total_return # Default if cannot annualize
    if 'Date' in df.columns and len(df) > 1:
        # Calculate the time span in years based on the Date column
        time_span = df['Date'].iloc[-1] - df['Date'].iloc[0]
        time_span_years = time_span.days / 365.25 # Use .days attribute of Timedelta
        if time_span_years > 0:
             annualized_return = (total_return + 1) ** (1 / time_span_years) - 1
        elif total_return != 0: # If time span is zero but there was a return, annualization is undefined/infinite
             annualized_return = float('inf') * np.sign(total_return) # Indicate infinite positive or negative return
        # If time_span_years is 0 and total_return is 0, annualized_return remains 0.


    # Calculate Sharpe Ratio - Needs returns over time, not just trade profits
    # A common way is to calculate daily returns of the portfolio.
    # Add basic net worth tracking.
    net_worth_history = [initial_capital]
    current_balance = initial_capital # Use a separate variable for balance tracking within metrics calc
    current_shares = 0 # Use a separate variable for shares tracking within metrics calc
    current_buy_price_for_equity = 0 # Track buy price for calculating holding value

    # Recalculate net worth history based on trading logic (simplified for equity curve)
    # A more accurate equity curve would track balance and shares held *each day*
    # based on the actions taken. Let's refine this.
    balance_history = [initial_capital]
    shares_history = [0] # Start with 0 shares
    daily_net_worth = [initial_capital]

    for i in range(1, len(df)):
        current_signal = df['Signal'].iloc[i] if 'Signal' in df.columns else 0
        current_close = df['Close'].iloc[i]
        current_stop_loss = df['Stop_Loss_Price'].iloc[i] if 'Stop_Loss_Price' in df.columns else np.nan

        # Apply the same trading logic to track balance and shares
        if current_signal == 1 and not shares_history[-1] > 0: # Buy signal and not in position (check previous day's shares)
             if current_close > 0:
                 shares_to_buy = balance_history[-1] // current_close
                 if shares_to_buy > 0:
                      balance_history.append(balance_history[-1] - shares_to_buy * current_close)
                      shares_history.append(shares_to_buy)
                 else: # Cannot buy, carry over previous state
                     balance_history.append(balance_history[-1])
                     shares_history.append(shares_history[-1])
             else: # Cannot buy, carry over previous state
                  balance_history.append(balance_history[-1])
                  shares_history.append(shares_history[-1])


        elif shares_history[-1] > 0: # If currently in a position
             sell_triggered = (current_signal == -1)
             # To check stop loss, we need the buy price. The previous loop structure stored it.
             # This equity curve calculation is becoming complex without tracking the buy price per position.
             # Let's simplify the equity curve calculation by just updating balance and shares.
             # The trade_logs provide the outcome of completed trades.

             # Revert to simpler net worth tracking based on executed trades for performance metrics
             # This is less accurate than a true daily equity curve but avoids complex state management here.
             # Let's calculate net worth *at the end of each day* based on the state (balance, shares) *after* potential trades on that day.

             temp_balance = balance_history[-1]
             temp_shares = shares_history[-1]
             # Need the buy price from the trade logs or track it separately.
             # Tracking buy price within the equity curve loop requires more state.
             # Let's assume the trade_logs are accurate outcomes for calculating metrics.

             # Alternative: Calculate daily net worth change based on market value + balance
             # This approach doesn't strictly need the trade execution logic inside the loop.
             # It needs balance and shares held at the *start* of the day.
             # Let's iterate through days and track net worth.

             # Correct Equity Curve Calculation
             # We need the state (balance, shares) at the *start* of each day `i`.
             # The decision on day `i` changes the state for the end of day `i`.

             # Start with initial capital at the beginning of day 0
             balance = initial_capital
             shares = 0
             buy_price = 0 # Buy price of the *current* position

             equity_curve_values = [initial_capital] # Equity at start of day 0

             for i in range(len(df)):
                 current_close = df['Close'].iloc[i]
                 current_signal = df['Signal'].iloc[i] if 'Signal' in df.columns else 0
                 current_stop_loss = df['Stop_Loss_Price'].iloc[i] if 'Stop_Loss_Price' in df.columns else np.nan

                 # Calculate net worth at the start of the current day (before any potential trade)
                 # This is (balance from end of previous day) + (shares held at end of previous day * current day's closing price)
                 # We need to track the state *after* day i-1's actions, for the *start* of day i.

                 # Let's use the state (balance, shares) *at the end* of the day.
                 # Equity at the *end* of day i is balance_after_trades_on_day_i + shares_after_trades_on_day_i * close_on_day_i

                 # State at the beginning of day i is the state at the end of day i-1.
                 # Let's track state updates based on actions on day i.

                 # Simplified state update logic for equity curve:
                 # Decide action based on day i's signal/price.
                 # Update balance/shares for the *end* of day i.
                 # Calculate equity at the end of day i.

                 # State at the end of day i-1 (start of day i)
                 balance_start_day_i = equity_curve_values[-1] # Assuming equity curve tracks balance + market value
                 shares_start_day_i = 0 # Need to track shares separately

                 # Let's rethink. A backtest simulation needs state (balance, shares, position status)
                 # and decision making loop. The original loop structure was mostly correct for this.
                 # The error was in the metrics calculation using trade logs.

                 # Let's go back to the original loop structure for state updates but fix metrics.
                 # The loop already updates balance and shares. We just need to record net worth *each day*.

             balance = initial_capital
             shares = 0
             in_position = False
             buy_price = 0 # Buy price of the current position
             net_worth_history = [initial_capital] # Net worth at the start of the first day

             for i in range(len(df)): # Iterate from day 0 to last day
                 current_close = df['Close'].iloc[i]
                 current_signal = df['Signal'].iloc[i] if 'Signal' in df.columns else 0
                 current_stop_loss = df['Stop_Loss_Price'].iloc[i] if 'Stop_Loss_Price' in df.columns else np.nan

                 # Calculate net worth at the *end* of day i based on the state (balance, shares)
                 # *before* decisions for day i are made, and the close price of day i.
                 # Then, apply trades for day i and update the state for the start of day i+1.
                 # This is slightly confusing. Let's calculate net worth *after* trades on day i.

                 # State *before* trades on day i is (balance, shares, in_position, buy_price) from the end of day i-1.
                 # Calculate net worth *at the end of day i* based on potential trades happening *on* day i.

                 # Actions for day i happen based on signal/price at day i.
                 # Balance and shares are updated based on these trades.
                 # Net worth at the end of day i is new balance + new shares * current_close.

                 # Let's store the state (balance, shares, in_position, buy_price) *after* processing day i.

                 new_balance = balance
                 new_shares = shares
                 new_in_position = in_position
                 new_buy_price = buy_price

                 # --- Trading Logic for Day i ---
                 if current_signal == 1 and not in_position:  # Buy signal and not in position
                     if current_close > 0:
                          shares_to_buy = balance // current_close # Integer division
                          if shares_to_buy > 0:
                               new_shares = shares + shares_to_buy
                               new_balance = balance - shares_to_buy * current_close
                               new_buy_price = current_close # Assuming average cost or first buy price
                               new_in_position = True

                 # Check for Sell or Stop-Loss trigger *on the current day*
                 elif in_position: # If currently in a position
                      sell_triggered = (current_signal == -1)
                      stop_loss_triggered = (not pd.isna(current_stop_loss) and current_close <= current_stop_loss)

                      if sell_triggered or stop_loss_triggered:
                         if shares > 0: # Only sell if shares are held
                             new_balance = balance + shares * current_close # Sell all shares
                             # Record the trade outcome *here* based on the buy_price from the *closed* position
                             trade_logs.append({"Buy_Price": buy_price, "Sell_Price": current_close, "Shares_Sold": shares, "Profit": (current_close - buy_price) * shares, "Exit_Date_Index": i})

                         new_shares = 0 # Shares are sold
                         new_in_position = False
                         new_buy_price = 0 # Reset buy price

                 # Update state for the next day
                 balance = new_balance
                 shares = new_shares
                 in_position = new_in_position
                 buy_price = new_buy_price # Update buy price if a new position was opened

                 # Calculate Net Worth at the end of Day i
                 equity_curve_day_i = balance + shares * current_close
                 net_worth_history.append(equity_curve_day_i)

             # Note: net_worth_history now contains initial capital + equity at the end of each trading day.
             # The last value is the final value.

             final_value = net_worth_history[-1]
             total_return = (final_value - initial_capital) / initial_capital


             # Recalculate metrics based on net_worth_history and trade_logs

             # Annualized Return
             annualized_return = total_return # Default if cannot annualize
             if 'Date' in df.columns and len(df) > 1:
                 time_span = df['Date'].iloc[-1] - df['Date'].iloc[0]
                 time_span_years = time_span.days / 365.25
                 if time_span_years > 0:
                      annualized_return = (total_return + 1) ** (1 / time_span_years) - 1
                 elif total_return != 0:
                      annualized_return = float('inf') * np.sign(total_return)


             # Sharpe Ratio
             # Calculate daily percentage returns from the equity curve
             net_worth_series = pd.Series(net_worth_history)
             daily_returns = net_worth_series.pct_change().dropna()

             sharpe_ratio = 0
             if len(daily_returns) > 0 and daily_returns.std() != 0:
                  sharpe_ratio = daily_returns.mean() / daily_returns.std() * np.sqrt(252) # Annualized Sharpe Ratio

             # Max Drawdown based on the equity curve
             max_drawdown_pct = 0
             if not net_worth_series.empty:
                 peak_equity = net_worth_series.cummax()
                 drawdowns = (peak_equity - net_worth_series) / peak_equity.replace(0, np.nan) # Avoid division by zero
                 max_drawdown_pct = drawdowns.max() * 100 if not drawdowns.empty else 0

             # Calculate Win Rate and Profit Factor from trade_logs
             wins = sum(1 for trade in trade_logs if trade["Profit"] > 1e-6) # Count positive profit
             losses = sum(1 for trade in trade_logs if trade["Profit"] < -1e-6) # Count negative profit
             total_trades = len(trade_logs)
             win_rate = wins / total_trades * 100 if total_trades > 0 else 0
             total_profit_wins = sum(trade["Profit"] for trade in trade_logs if trade["Profit"] > 0)
             total_loss_losses = abs(sum(trade["Profit"] for trade in trade_logs if trade["Profit"] < 0))
             profit_factor = total_profit_wins / total_loss_losses if total_loss_losses > 1e-6 else (float('inf') if total_profit_wins > 0 else 0)

             # --- End Performance Metrics Calculation ---


    metrics = {
        "Initial Capital": initial_capital,
        "Final Value": final_value,
        "Total Return": total_return,
        "Annualized Return": annualized_return,
        "Sharpe Ratio": sharpe_ratio,
        "Max Drawdown %": max_drawdown_pct,
        "Win Rate %": win_rate,
        "Profit Factor": profit_factor,
        "Total Trades": total_trades
    }
    return metrics

# Backtest the strategy
# Ensure df_with_stop_loss has the correct columns and index before calling
# Assuming df_with_stop_loss has 'Signal', 'Close', 'Stop_Loss_Price', and 'Date' (for annualization)
# Let's ensure the DataFrame passed to backtest_strategy has a clean integer index if needed
# The .iloc usage should handle a non-integer index, but let's be safe.
# Revert to just passing the potentially fixed df_with_stop_loss.

df_to_backtest = df_with_stop_loss.copy() # Work on a copy

# Explicitly ensure 'Date' is datetime before backtesting
if 'Date' in df_to_backtest.columns:
    df_to_backtest['Date'] = pd.to_datetime(df_to_backtest['Date'], errors='coerce')
    df_to_backtest.dropna(subset=['Date'], inplace=True)
    if df_to_backtest['Date'].dt.tz is not None:
         df_to_backtest['Date'] = df_to_backtest['Date'].dt.tz_convert(None)


# Ensure the DataFrame has enough rows after potential drops for backtesting loop (at least 2 for date diff)
if len(df_to_backtest) > 1:
    backtest_results = backtest_strategy(df_to_backtest)
    print("Backtesting Results:")
    for metric, value in backtest_results.items():
        print(f"{metric}: {value:.4f}")
else:
    print("DataFrame too short for backtesting after processing.")

"""
# Extra Code
"""

import unittest
import pandas as pd
import numpy as np

# --- Example: Testing Feature Engineering ---
def create_features(df):
    """ (Your existing create_features function) """
    df['MA_5'] = df['Close'].rolling(window=5).mean()
    df['RSI'] = 100.0  # Simplified for testing
    df.dropna(inplace=True)
    return df

class TestFeatureEngineering(unittest.TestCase):

    def setUp(self):
        # Create a sample DataFrame for testing
        self.data = {'Close': [10, 11, 12, 13, 14, 15]}
        self.df = pd.DataFrame(self.data)

    def test_moving_average(self):
        df_with_ma = create_features(self.df.copy())
        self.assertTrue('MA_5' in df_with_ma.columns)
        # Check if the first MA_5 value is NaN (because of rolling window)
        self.assertTrue(np.isnan(df_with_ma['MA_5'].iloc[0]))
        # Check a valid MA_5 calculation (simplified)
        #self.assertAlmostEqual(df_with_ma['MA_5'].iloc[4], 12.0) # Replace with actual expected value

    def test_rsi_calculation(self):
         df_with_rsi = create_features(self.df.copy())
         self.assertTrue('RSI' in df_with_rsi.columns)
         self.assertTrue(all(df_with_rsi['RSI'] == 100.0)) #test simplified RSI


# --- Example: Testing Data Preprocessing ---
def preprocess_data(df):
    """ (Your existing preprocess_data function) """
    df.fillna(method='ffill', inplace=True)
    return df

class TestDataPreprocessing(unittest.TestCase):

    def setUp(self):
        self.data_with_nan = {'Close': [10, np.nan, 12, 13, np.nan, 15]}
        self.df_with_nan = pd.DataFrame(self.data_with_nan)

    def test_fillna_forward(self):
        filled_df = preprocess_data(self.df_with_nan.copy())
        self.assertTrue(not filled_df['Close'].isnull().any())
        self.assertEqual(filled_df['Close'][1], 10.0)
        self.assertEqual(filled_df['Close'][4], 13.0)


if __name__ == '__main__':
    unittest.main(argv=['first-arg-is-ignored'], exit=False) #Colab needs this

import pandas as pd
import numpy as np

def backtest_strategy(df, initial_capital=10000, verbose=False):  # Added verbose
    """ (Your backtest_strategy function with potential enhancements) """

    balance = initial_capital
    shares = 0
    in_position = False
    buy_price = 0
    trade_logs = []

    for i in range(1, len(df)):
        if df['Signal'][i] == 1 and not in_position:
            shares = balance // df['Close'][i]
            balance -= shares * df['Close'][i]
            buy_price = df['Close'][i]
            in_position = True
            if verbose:
                print(f"Buy at {df['Date'][i]}, Price: {df['Close'][i]}, Shares: {shares}")
        elif (df['Signal'][i] == -1 and in_position) or (
                df['Close'][i] <= df['Stop_Loss_Price'][i] and in_position):
            sell_price = df['Close'][i]
            profit = (sell_price - buy_price) * shares
            balance += shares * sell_price
            shares = 0
            in_position = False
            trade_logs.append({"Buy_Price": buy_price, "Sell_Price": sell_price, "Shares": shares, "Profit": profit})
            if verbose:
                print(f"Sell at {df['Date'][i]}, Price: {df['Close'][i]}, Profit: {profit}")

    final_value = balance
    if in_position:
        final_value += shares * df['Close'].iloc[-1]

    total_return = (final_value - initial_capital) / initial_capital
    annualized_return = (final_return + 1) ** (252 / len(df)) - 1 if len(df) > 252 else total_return #Added check
    sharpe_ratio = 0 #Initialize
    max_drawdown_pct = 0 #Initialize
    win_rate = 0 #Initialize
    profit_factor = 0 #Initialize

    if len(trade_logs) > 1:
        trade_profits = pd.DataFrame(trade_logs)['Profit']
        sharpe_ratio = trade_profits.mean() / trade_profits.std() * np.sqrt(252) if trade_profits.std() else 0

        peak = initial_capital
        drawdown = 0
        for value in df['Close']:
            peak = max(peak, value)
            drawdown = max(drawdown, peak - value)
        max_drawdown_pct = (drawdown / initial_capital) * 100 if initial_capital > 0 else 0

        wins = sum(1 for trade in trade_logs if trade["Profit"] > 0)
        losses = sum(1 for trade in trade_logs if trade["Profit"] < 0)
        win_rate = wins / len(trade_logs) * 100 if trade_logs else 0
        profit_factor = sum(trade["Profit"] for trade in trade_logs if trade["Profit"] > 0) / abs(
            sum(trade["Profit"] for trade in trade_logs if trade["Profit"] < 0)) if losses else float('inf')

    metrics = {
        "Total Return": total_return,
        "Annualized Return": annualized_return,
        "Sharpe Ratio": sharpe_ratio,
        "Max Drawdown %": max_drawdown_pct,
        "Win Rate %": win_rate,
        "Profit Factor": profit_factor,
        "Final Value": final_value #Added
    }

    if verbose:
        print(f"--- Trade Logs ({len(trade_logs)} trades) ---")
        for log in trade_logs:
            print(log)
        print("--- End of Trade Logs ---")

    return metrics

# Example Usage (assuming you have 'df_with_signals' from previous steps)
backtest_results = backtest_strategy(df_with_signals.copy(), initial_capital=10000, verbose=True) #Added verbose
print("\nBacktesting Results:")
for metric, value in backtest_results.items():
    print(f"{metric}: {value:.4f}")

